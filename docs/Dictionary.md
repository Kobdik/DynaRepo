## Dictionary First
 
Обычно, изменения в структуре БД приводят к вынужденной перекомпиляции модулей, как это происходит со сгенерированными частичными классами сущностей в `EF`. Для устойчивости к изменениям `DynaObject` использует словари метаданных, сохраняемые в самой БД в виде таблиц описания запросов, передаваемых параметров и возвращаемых колонок полей.

T_QryDict - таблица описания запросов, вот некоторые столбцы:

| Qry_Id | Qry_Name | Qry_Head                | Col_Def |
|--------|----------|-------------------------|---------|
|     27 | Invoice  | Счета                   |      27 |
|     28 | InvoCut  | Счета(усеченный запрос) |      28 |

По соглашению к запросу Invoice относятся хранимая процедура на выборку sel_Invoice, на детализацию - det_Invoice, на вставку - ins_Invoice, на изменение - upd_Invoice. Соответственно, к запросу InvoCut относятся хранимые процедуры sel_InvoCut, det_InvoCut, ins_InvoCut, upd_InvoCut. Данные процедуры могут быть нацелены на одну и ту же таблицу.

T_PamDict - таблица параметров select-запросов, вот основные столбцы:

| Qry_Id | Pam_Id | Pam_Name | Pam_Head      | Pam_Type | Pam_Size |
|--------|--------|----------|---------------|----------|----------|
|     27 |      1 |   Dt_Fst |Начальная дата |       40 |        3 |
|     27 |      2 |   Dt_Lst |Конечная дата  |       40 |        3 |

У запроса sel_Invoice имеется два параметра типа BbType.Date (в таблице указано числовое значение перечисления), а у sel_InvoCut параметров нет.

T_ColDict - сводная таблица описания полей, участвующих в запросах (показаны не все столбцы):

| Qry_Id | Col_Id | Col_Name | Col_Head       | Col_Type | Col_Size | Note       | Col_Flag |
|--------|--------|----------|----------------|----------|----------|------------|----------|
|27      | 0      | Idn      | Код начисления | 56       | 4        | idn,out    | 9        |
|27      | 1      | Org      | Контрагент     | 52       | 2        | sel,det    | 6        |
|27      | 2      | Knd      | Вид начисления | 48       | 1        | sel,det    | 6        |
|27      | 3      | Dt_Invo  | Дата начисления| 40       | 3        | sel,det    | 6        |
|27      | 4      | Val      | Начислено      | 62       | 8        | sel,det    | 6        |
|27      | 5      | Crs      | Квитовано      | 62       | 8        |            | 0        |
|27      | 6      | Ost      | Остаток        | 62       | 8        |            | 0        |
|27      | 7      | Note     | Примечание     | 167      | 100      | sel,det    | 6        |
|27      | 8      | Sdoc     | Состояние док. | 48       | 1        | det,opt    | 20       |
|27      | 9      | Dt_Sdoc  | Дата изм. сост.| 40       | 3        | det,opt    | 20       |
|27      | 10     | Lic      | Лицензия       | 56       | 4        | sel,det    | 6        |
|27      | 11     | Usr      | Пользователь   | 167      | 15       | usr        | 32       |
|27      | 12     | Pnt      | Получатель     | 48       | 1        | sel,det    | 6        |
|28      | 0      | Idn      | Код начисления | 56       | 4        | idn,out    | 9        |
|28      | 1      | Dt_Invo  | Дата начисления| 40       | 3        | sel,det    | 6        |
|28      | 2      | Val      | Начислено      | 62       | 8        | sel,det,out| 14       |
|28      | 3      | Note     | Примечание     | 167      | 100      | sel,det,out| 14       |

Операция sel_Invoice на выборку данных может выглядеть так:
```
create proc [dbo].[sel_Invoice] @Dt_Fst date, @Dt_Lst date
as 
 select n.Idn, n.Org, n.Knd, n.Dt_Invo, n.Val, n.Note, n.Lic, n.Pnt
 from dbo.T_Invoice n where n.Dt_Invo between @Dt_Fst and @Dt_Lst
return 0;
```
По соглашению при исполнении sel_Invoice будут выбраны значения только тех колонок, где включены биты idn(1) и sel(2). Col_Flag как раз и определяет маску (сумму) битовых флагов колонки (idn - 1, sel - 2, det - 4, out - 8, opt - 16, usr - 32). Даже, если в select-запросе будет присутствовать поле Sdoc, у которого маска флагов 20=4+16, бит sel(2) не включен, в выходной поток значение из этого поля не попадет. 

Битовым флагом sel помечены колонки полей отображаемых в списках. В реальном приложении поле Note в списке не отображается (бит sel выключен), оно слишком длинное и будет запрашиваться только при запросе на детализацию выбранной строки списка. Детализации строки в данном случае соответствует отдельная операция det_Invoice, которая может выглядеть так:
```
create proc [dbo].[det_Invoice] @Idn int
as 
 select n.Idn, n.Org, n.Knd, n.Dt_Invo, n.Val, n.Note, n.Sdoc, n.Dt_Sdoc, n.Lic, n.Usr, n.Pnt
 from dbo.T_Invoice n 
 where n.Idn=@Idn
return 0;
```
По соглашению при исполнении det_Invoice в выходной поток попадут значения только тех колонок, где включены биты idn(1), sel(2), det(4) и usr(32).

Операция upd_Invoice на изменение данных может выглядеть так:
```
create proc [dbo].[upd_Invoice]
@Idn int out, @Dt_Invo date, @Org smallint, @Knd tinyint,  @Val float, @Note varchar(100), @Lic int, @Usr varchar(15), @Pnt tinyint
as
  update dbo.T_Invoice 
  set Org=@Org, Knd=@Knd, Dt_Invo=@Dt_Invo, Val=@Val, Note=@Note, Lic=@Lic, Usr=@Usr, Sts=2, Chg=GETDATE(), Pnt=@Pnt
  where Idn=@Idn
return 0;
```
Также по соглашению при исполнении ins_Invoice и upd_Invoice по умолчанию из входного потока будут выбраны значения только тех колонок, где включены биты idn(1), det(4), out(8) и usr(32), для каждой такой колонки будет создан входной параметр нужного типа и размера. Для колонок с битом out(8) параметры получат ParameterDirection.InputOutput, после исполнения хранимой процедуры, выходные значения будут считаны и записаны в выходной поток. 

Для хранения словарей метаданных служит `singleton` экземпляр класса DataMod, который через фабричный метод `public DynaObject GetDynaObject(string queryName)` создаёт объекты `DynaObject` и снабжает их метаданными из своих своих словарей. Подробнее посмотрите в коде: [DataMod](https://github.com/Kobdik/DynaRepo/blob/master/DynaLib/DataModule.cs) 

Изменяя хранимые процедуры, следует внести соответствующие изменения в словари метаданных и после их повторной загрузки новый объект `DynaObject` будет готов работать с новой структурой. Такое обновление словаря можно будет осуществлять без остановки WEB API или сервера приложения, но пока не реализовано.

Ориентация на оптимизированные специалистом БД хранимые процедуры, разграничение прав доступа к ним, по меньшей мере дисциплинирует программиста .NET, снижает вероятность непреднамеренного нарушения целостности данных, либо компрометации конфиденциальных данных.

На основе словарей метаданных нетрудно сгенерировать хранимые процедуры select, insert, update и delete запросов, потом скорректировать вручную необходимое. Например, возьмём запрос *Invoice*. Имя целевой таблицы по соглашению о наименовании запросов будет *dbo.T_Invoice*. Для хранимой процедуры *upd_Invoice* на основе битовых флагов idn, det, out и usr вычисляются затрагиваемые поля и параметры запроса. Останется только дописать, например: "Sts=2, Chg=GETDATE()". 

В настоящее время утилиты администрирования хранимых процедур находятся в стадии рефакторинга и не включены в библиотеку. Однако, уже сейчас можно сгенерировать строку с объявлением хранимой процедуры, вызвав у экземпляра `DynaObject` метод `GetInfo(string kind)` с соответствующим параметром `select, detail, insert, update`. Пример сгенерированного текстового файла с хранимыми процедурами [Stored procs](https://github.com/Kobdik/DynaRepo/blob/master/QueryApp/Stored_Procs.txt)

Хранение метаданных в таблицах БД позволяет использовать их в различных средах. Например, в далёком 2008 портировал свои коды с C++ Builder в C#, словари оставались те же, как и хранимые процедуры, что существенно ускорило переход. Другой пример, имеется 3-х звенное приложение, которое совместно с WEB API приложением использует одну и ту же базу, общие словари. Клиент WEB API - SPA на собственном js-фреймворке, также использует те же общие словари. В этом быстро изменяющемся мире База Данных представляет собой оплот стабильности, всё ценное целесообразно хранить именно там.
