# DynaLib

Основной целью проекта является разработка инструментария на базе ADO.NET, для вызова хранимых процедур БД, передачи возвращаемых данных из `IDataReader` сразу в выходной поток без необходимости создания объектов модели для последующей их сериализации. Такой подход применим при реализации трёх-звенной архитектуры приложения или WEB API интерфейса, так как на стороне сервера нет необходимости во взаимодействии с объектами-сущностями, достаточно лишь последовательно прочитать из реализации `IDataReader` данные свойств и записать их в поток.

Высокая скорость работы `SqlDataReader` обусловлена применением `FAST_FORWARD` курсора на стороне БД, однако, непосредственно использовать его неудобно, получается слишком много ручного кодирования. Поэтому, для доступа к данным прибегают к помощи `EF` (Entity Framework), который внутренне использует `SqlDataReader`, однако, скорость загрузки данных падает от 3-х до более чем в 10 раз. Забегая вперёд скажу, что в моих тестовых замерах производительности относительная скорость `EF` ниже в 3.7 раза при больших выборках, когда запрос возвращает более 70 000 записей, а на малых выборках, менее 1 000 записей, относительная скорость падает в 17 раз!

Кроме того, `EF` расходует в 3 раза больше памяти, создавая дополнительную работу для сборщика мусора. Использование страничных запросов для снижения расхода памяти не только нагружает серверную сторону частыми обращениями, но и приводит в режим малых выборок, где относительная производительность `EF` в 17 раз ниже. Получается, что при частых обращениях клиентов к WEB API приложению с запросами, возвращающими малые выборки, следует отказаться от использования `EF` для доступа к данным, конечно, если вы не решили кэшировать всю базу в памяти.

Для решения проблем с производительностью `EF`, а точнее, для того чтобы не использовать его вовсе, была разработана библиотека `DynaLib`, главная роль в которой принадлежит классу `DynaObject`, который умеет читать параметры из входного потока, вызывать хранимые процедуры на стороне БД, непосредственно работать с `IDataReader`, записывая данные из него в выходной поток в `binary`, `json` или `xml` форматах.

## Dictionary First

Если задача серверного приложения переслать клиентской программе данные табличного запроса, то почему обязательно сначала создавать сущности, затем инициализировать, считывая  из `IDataReader` их свойства, а затем уже сериализовать эти объекты в выходной поток? Чем один запрос отличается от другого? - Параметрами и набором возвращаемых колонок. Зная эти метаданные можно вызвать хранимую процедуру, прочитать результат и выгрузить его в поток. При этом на стороне сервера не нужно плодить классы модели, классы контроллеров, при изменении структуры запроса не нужно перекомпилировать приложение, главное знать актуальные метаданные. 

Организация словарей метаданных в форме таблиц описаний, позволяет эффективно управлять запросами на основе хранимых процедур, унифицирует и упрощает обработку данных, способствует применению декларативного стиля программирования. Подробнее тут: [Dictionary First](Dictionary.md)

## DynaObject

Для создания объектов `DynaObject` используется фабричный метод `IDynaObject DataMod.GetDynaObject(string queryName)`. Singleton экземпляр DataMod при инициализации загружает всю необходимую мета-информацию из БД, используемую при создании объектов, а также снабжает их `binary`, `json` или `xml` форматтерами для записи и чтения из потоков.

На стороне контроллера объекты `DynaObject` доступны через реализуемый ими интерфейс `IDynaObject`: 
```csharp
//Через интерфейс удобнее и 
//безопаснее работать с объектом
public interface IDynaObject : IDisposable
{
 //описания параметров select-запроса
 Dictionary<String, IDynaProp> ParmDict { get; }
 //описания колонок запросов
 Dictionary<String, IDynaProp> PropDict { get; }
 //читает из потока значения select-параметров 
 //или значения колонок при insert/update
 void ReadPropStream(Stream stream, string cmd);
 //пишут результаты запросов в выходной поток
 void SelectToStream(Stream stream);
 void DetailToStream(Stream stream, int idn);
 void ActionToStream(Stream stream, string cmd);
 //Служит для целей отладки, возвращает
 //имена и значения колонок PropDict
 string GetInfo();
}
```



